package tools

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/nextlevelbuilder/goclaw/internal/sandbox"
)

// EditTool performs search-and-replace edits on files.
// Supports context file interceptor (managed mode) and sandbox routing.
type EditTool struct {
	workspace       string
	restrict        bool
	sandboxMgr      sandbox.Manager
	contextFileIntc *ContextFileInterceptor
	memIntc         *MemoryInterceptor
}

func (t *EditTool) SetContextFileInterceptor(intc *ContextFileInterceptor) {
	t.contextFileIntc = intc
}

func (t *EditTool) SetMemoryInterceptor(intc *MemoryInterceptor) {
	t.memIntc = intc
}

func NewEditTool(workspace string, restrict bool) *EditTool {
	return &EditTool{workspace: workspace, restrict: restrict}
}

func NewSandboxedEditTool(workspace string, restrict bool, mgr sandbox.Manager) *EditTool {
	return &EditTool{workspace: workspace, restrict: restrict, sandboxMgr: mgr}
}

func (t *EditTool) SetSandboxKey(key string) {}

func (t *EditTool) Name() string { return "edit" }
func (t *EditTool) Description() string {
	return "Edit a file by replacing exact text matches. Use old_string/new_string for precise edits without rewriting the entire file."
}

func (t *EditTool) Parameters() map[string]interface{} {
	return map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			"path": map[string]interface{}{
				"type":        "string",
				"description": "Path to the file to edit",
			},
			"old_string": map[string]interface{}{
				"type":        "string",
				"description": "Exact text to find (must match uniquely unless replace_all is true)",
			},
			"new_string": map[string]interface{}{
				"type":        "string",
				"description": "Replacement text",
			},
			"replace_all": map[string]interface{}{
				"type":        "boolean",
				"description": "Replace all occurrences (default: false, requires unique match)",
			},
		},
		"required": []string{"path", "old_string", "new_string"},
	}
}

func (t *EditTool) Execute(ctx context.Context, args map[string]interface{}) *Result {
	path, _ := args["path"].(string)
	oldStr, _ := args["old_string"].(string)
	newStr, _ := args["new_string"].(string)
	replaceAll, _ := args["replace_all"].(bool)

	if path == "" {
		return ErrorResult("path is required")
	}
	if oldStr == "" {
		return ErrorResult("old_string is required")
	}
	if oldStr == newStr {
		return ErrorResult("old_string and new_string are identical")
	}

	// Virtual FS: context files (managed mode)
	if t.contextFileIntc != nil {
		if content, handled, err := t.contextFileIntc.ReadFile(ctx, path); handled {
			if err != nil {
				return ErrorResult(fmt.Sprintf("failed to read context file: %v", err))
			}
			if content == "" {
				return ErrorResult(fmt.Sprintf("context file not found: %s", path))
			}
			newContent, result := applyEdit(content, oldStr, newStr, replaceAll)
			if result != nil {
				return result
			}
			if _, err := t.contextFileIntc.WriteFile(ctx, path, newContent); err != nil {
				return ErrorResult(fmt.Sprintf("failed to write context file: %v", err))
			}
			return SilentResult(fmt.Sprintf("Context file edited: %s", path))
		}
	}

	// Virtual FS: memory files (managed mode)
	if t.memIntc != nil {
		if content, handled, err := t.memIntc.ReadFile(ctx, path); handled {
			if err != nil {
				return ErrorResult(fmt.Sprintf("failed to read memory file: %v", err))
			}
			if content == "" {
				return ErrorResult(fmt.Sprintf("memory file not found: %s", path))
			}
			newContent, result := applyEdit(content, oldStr, newStr, replaceAll)
			if result != nil {
				return result
			}
			if _, err := t.memIntc.WriteFile(ctx, path, newContent); err != nil {
				return ErrorResult(fmt.Sprintf("failed to write memory file: %v", err))
			}
			return SilentResult(fmt.Sprintf("Memory file edited: %s", path))
		}
	}

	// Sandbox routing
	sandboxKey := ToolSandboxKeyFromCtx(ctx)
	if t.sandboxMgr != nil && sandboxKey != "" {
		return t.executeInSandbox(ctx, path, oldStr, newStr, replaceAll, sandboxKey)
	}

	// Host execution
	resolved, err := resolvePath(path, t.workspace, t.restrict)
	if err != nil {
		return ErrorResult(err.Error())
	}

	data, err := os.ReadFile(resolved)
	if err != nil {
		return ErrorResult(fmt.Sprintf("failed to read file: %v", err))
	}

	content := string(data)
	newContent, result := applyEdit(content, oldStr, newStr, replaceAll)
	if result != nil {
		return result
	}

	if err := os.MkdirAll(filepath.Dir(resolved), 0755); err != nil {
		return ErrorResult(fmt.Sprintf("failed to create directory: %v", err))
	}

	if err := os.WriteFile(resolved, []byte(newContent), 0644); err != nil {
		return ErrorResult(fmt.Sprintf("failed to write file: %v", err))
	}

	count := strings.Count(content, oldStr)
	return SilentResult(fmt.Sprintf("File edited: %s (%d replacement(s))", path, count))
}

func (t *EditTool) executeInSandbox(ctx context.Context, path, oldStr, newStr string, replaceAll bool, sandboxKey string) *Result {
	sb, err := t.sandboxMgr.Get(ctx, sandboxKey, t.workspace)
	if err != nil {
		return ErrorResult(fmt.Sprintf("sandbox error: %v", err))
	}

	bridge := sandbox.NewFsBridge(sb.ID(), "/workspace")
	content, err := bridge.ReadFile(ctx, path)
	if err != nil {
		return ErrorResult(fmt.Sprintf("failed to read file: %v", err))
	}

	newContent, result := applyEdit(content, oldStr, newStr, replaceAll)
	if result != nil {
		return result
	}

	if err := bridge.WriteFile(ctx, path, newContent); err != nil {
		return ErrorResult(fmt.Sprintf("failed to write file: %v", err))
	}

	count := strings.Count(content, oldStr)
	return SilentResult(fmt.Sprintf("File edited: %s (%d replacement(s))", path, count))
}

// applyEdit performs the search-and-replace. Returns (newContent, nil) on success
// or ("", errorResult) on failure.
func applyEdit(content, oldStr, newStr string, replaceAll bool) (string, *Result) {
	count := strings.Count(content, oldStr)
	if count == 0 {
		return "", ErrorResult("old_string not found in file")
	}
	if !replaceAll && count > 1 {
		return "", ErrorResult(fmt.Sprintf("old_string found %d times â€” use replace_all=true or provide a more specific match", count))
	}

	if replaceAll {
		return strings.ReplaceAll(content, oldStr, newStr), nil
	}
	return strings.Replace(content, oldStr, newStr, 1), nil
}
